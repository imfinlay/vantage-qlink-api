<!-- index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="stylesheet" href="/site.css">
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>TCP Command Console</title>
</head>
<body>
  <h1>TCP Command Console</h1>

  <div class="card">
    <h2>Logs Tail</h2>
    <div class="row" style="flex-wrap:wrap;gap:.5rem 1rem;align-items:center;">
      <label>Limit <input id="log-limit" type="number" min="10" max="2000" step="10" value="200" /></label>
      <label>Interval (ms) <input id="log-interval" type="number" min="250" step="250" value="2000" /></label>
      <label><input id="auto-scroll" type="checkbox" checked /> Auto-scroll</label>
      <!-- NEW: local text filter triggers render only -->
      <label>Text filter <input id="log-filter" type="text" placeholder="type to filter..." oninput="renderLogView()" /></label>
      <button class="btn" id="tail-toggle" onclick="toggleTail()">Start Tail</button>
      <button class="btn" onclick="doLogFetchOnce()">Fetch Once</button>
      <button class="btn" onclick="clearLogView()">Clear View</button>
    </div>
    <div id="log-container" class="card" style="margin-top:8px;max-height:360px;overflow-y:auto;"></div>
  </div>

<script>
  // ---- helpers & prefs ----
  const $ = (sel) => document.querySelector(sel);

  function fetchWithTimeout(url, opts = {}) {
    const timeoutMs = Number(opts.timeoutMs == null ? 8000 : opts.timeoutMs);
    const ctl = new AbortController();
    const id = setTimeout(() => ctl.abort(new Error('timeout')), Math.max(1, timeoutMs));
    const p = fetch(url, { ...opts, signal: opts.signal || ctl.signal });
    p.finally(() => clearTimeout(id));
    return p;
  }

  // globals used by tailing logic
  let currentLogFetchAbort = null;
  let tailBusy = false;
  let tailTimer = null;
  const LOG_DOM_CAP = 1000;
  // Cache of last fetched lines so filtering is instant and local
  let __logLines = [];

  function autoScrollIfNeeded(){
    if (!$('#auto-scroll') || !$('#auto-scroll').checked) return;
    const c = $('#log-container');
    c.scrollTop = c.scrollHeight + 1000;
  }

  function clearLogView(){ const el = $('#log-container'); if (el) el.textContent=''; }

  function toggleTail(){
    const btn = $('#tail-toggle');
    if (tailTimer) {
      clearInterval(tailTimer); tailTimer = null; if (btn) btn.textContent = 'Start Tail';
    } else {
      const base = Math.max(250, Number($('#log-interval')?.value || 2000));
      tailTimer = setInterval(doLogFetchOnce, base);
      if (btn) btn.textContent = 'Stop Tail';
    }
  }

  async function doLogFetchOnce(){
    if (tailBusy) return; tailBusy = true;
    try {
      const limit = Number($('#log-limit')?.value || 200);
      if (currentLogFetchAbort) { try { currentLogFetchAbort.abort(); } catch(_){} }
      currentLogFetchAbort = new AbortController();
      const interval = Number($('#log-interval')?.value || 2000);
      const timeoutMs = Math.max(2000, interval * 2);

      // Expect server endpoint /logs?limit=..&format=txt (non-breaking vs your backend)
      const r = await fetchWithTimeout(`/logs?limit=${limit}&format=txt`, { signal: currentLogFetchAbort.signal, timeoutMs });
      if (!r.ok) throw new Error('HTTP ' + r.status);
      const t = await r.text();

      // Normalize line endings and cache
      const t2 = t.replace(/
/g, '
').replace(//g, '
');
      __logLines = t2.split('
').filter(Boolean);

      // Draw from cache (filter applied locally)
      renderLogView();
    } catch (e) {
      // Also print errors into the view so user sees them
      const el = $('#log-container');
      if (el) {
        const p = document.createElement('p');
        p.className = 'logLine cat-error';
        p.textContent = '[client] log fetch failed: ' + (e && e.message ? e.message : e);
        el.appendChild(p);
      }
    } finally {
      tailBusy = false; currentLogFetchAbort = null;
    }
  }

  // Pretty printer (kept simple; no regex literals)
  function renderLogLinePretty(line){
    const node = document.createElement('div');
    node.className = 'logLine';

    let ts = '';
    let rest = line;
    if (line && line.charAt(0) === '[') {
      const rb = line.indexOf(']');
      if (rb > 0) { ts = line.substring(1, rb); rest = line.substring(rb + 1); if (rest.charAt(0) === ' ') rest = rest.substring(1); }
    }

    const tsSpan = document.createElement('span');
    tsSpan.className = 'ts';
    tsSpan.textContent = ts ? ('[' + ts + '] ') : '';
    node.appendChild(tsSpan);

    const body = document.createElement('span');
    body.textContent = rest;

    const low = rest.toLowerCase();
    let cls = '';
    if (rest.indexOf('HTTP') === 0) cls = 'http';
    else if (rest.indexOf('CMD') === 0 || rest.indexOf('CMD/API') !== -1) cls = 'cmd';
    else if (rest.indexOf('RX <-') === 0 || rest.indexOf(' RX <-') !== -1) cls = 'rx';
    else if (low.indexOf('push') !== -1) cls = 'push';
    else if (low.indexOf('error') !== -1) cls = 'error';

    body.className = 'cat-' + (cls || 'plain');
    node.appendChild(body);
    return { node };
  }

  // NEW: pure renderer that applies the text filter locally
  function renderLogView(){
    const el = $('#log-container');
    if (!el) return;
    const filt = ($('#log-filter')?.value || '').toLowerCase();

    const frag = document.createDocumentFragment();
    let count = 0;
    for (const rawLine of __logLines) {
      if (!rawLine) continue;
      if (filt && rawLine.toLowerCase().indexOf(filt) === -1) continue;
      const { node } = renderLogLinePretty(rawLine);
      frag.appendChild(node);
      if (++count >= LOG_DOM_CAP) break;
    }
    el.innerHTML = '';
    el.appendChild(frag);
    autoScrollIfNeeded();
  }

  // Initial auto-start tailing
  window.addEventListener('load', () => {
    toggleTail();      // start tailing
    doLogFetchOnce();  // and draw immediately once
  });
</script>

</body>
</html>

/* io.js */
'use strict';
const express = require('express');
const router = express.Router();
const ctx = require('../core/context');
const { logLine, tailFile } = require('../core/logger');
const { sendToTCP, sendCmdLogged } = require('../core/tcp');
const { runQueued, sleep } = require('../core/queue');

// Existing JS content from io.js goes here

module.exports = router;

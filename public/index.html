<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>TCP Command Console</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 16px; }
    h1 { margin: 0 0 8px; }
    h2 { margin: 20px 0 8px; font-size: 1.1rem; }
    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .card { border: 1px solid #ddd; border-radius: 8px; padding: 12px; margin-top: 12px; }
    .btn { cursor: pointer; padding: 6px 10px; border: 1px solid #888; border-radius: 6px; background:#fafafa; }
    .btn:hover { background:#f0f0f0; }
    .btn.primary { background: #0069ff; color: white; border-color: #0060e6; }
    .btn.primary:hover { background:#0058d9; }
    input[type="text"], input[type="number"], select { padding: 6px; border: 1px solid #ccc; border-radius: 6px; }
    table { border-collapse: collapse; width: 100%; }
    th, td { border-bottom: 1px solid #eee; padding: 6px 8px; text-align: left; }
    tbody tr { cursor: pointer; }
    tbody tr:hover { background: #f7faff; }
    .monospace { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .small { font-size: 0.85rem; color: #555; }
    #queue { white-space: pre-wrap; font-size: 12px; color:#333; }
    .logLine { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; white-space: pre-wrap; margin: 0; padding: 0; }
    .logLine .ts { color: #666; margin-right: 4px; }
    .cat-http { color: #0366d6; }
    .cat-cmd { color: #795548; }
    .cat-rx { color: #2e7d32; }
    .cat-push { color: #6a1b9a; }
    .cat-error { color: #d32f2f; }
    #log-container { overflow-y: auto; font-size: 12px; border: 1px solid #ddd; border-radius: 8px; padding: 8px; background: #fff; }
  </style>
</head>
<body>

  <h1>TCP Command Console</h1>
  <div class="row">
    <label>Server:
      <select id="server-select"></select>
    </label>
    <button class="btn" onclick="doConnect()">Connect</button>
    <button class="btn" onclick="doDisconnect()">Disconnect</button>
    <span id="conn-status" class="small">Not connected</span>
  </div>

  <div class="card">
    <h2>Send Command</h2>
    <div class="row">
      <input id="command-input" type="text" placeholder="Type command (e.g., VGS 2 20 7)" size="40" class="monospace" />
      <button class="btn primary" onclick="onSendClick()">Send</button>
    </div>

    <div style="margin-top: 8px;" class="row">
      <strong>Response Mode:</strong>
      <label><input type="radio" name="modifier" value="" checked /> None</label>
      <label><input type="radio" name="modifier" value="$" /> $ (short, after command)</label>
      <label><input type="radio" name="modifier" value="#" /> # (detailed, after command)</label>
    </div>

    <div class="row" style="margin-top: 8px;">
      <strong>Wait / Collect:</strong>
      <label><input id="wait-response" type="checkbox" /> Wait for response</label>
      <label>quietMs <input id="quiet-ms" type="number" min="0" value="300" /></label>
      <label>maxMs <input id="max-ms" type="number" min="0" value="2000" /></label>
    </div>

    </div>

  </div>

  <div class="card">
    <h2>Commands</h2>
    <div style="display: flex; gap: 8px; align-items: center;">
      <label>Filter: <input id="cmd-filter" type="text" placeholder="Search..." oninput="renderCommandsTable()" /></label>
      <span class="small">Click a row to copy into the input.</span>
    </div>
    <div style="max-height: 260px; overflow-y: auto;">
      <table>
        <thead>
          <tr>
            <th style="width: 200px;">Command</th>
            <th>Description</th>
            <th style="width: 300px;">Params</th>
          </tr>
        </thead>
        <tbody id="command-tbody"></tbody>
      </table>
    </div>
  </div>

  <div class="card">
    <h2>Queue + Status</h2>
    <pre id="queue" class="monospace"></pre>
  </div>

  <div class="card">
    <h2>Logs Tail</h2>
    <div class="row">
      <label>Limit <input id="log-limit" type="number" min="10" max="2000" step="10" value="200" /></label>
      <label>Interval (ms) <input id="log-interval" type="number" min="250" step="250" value="2000" /></label>
      <label><input id="auto-scroll" type="checkbox" checked /> Auto-scroll</label>
      <button class="btn" id="tail-toggle" onclick="toggleTail()">Stop Tail</button>
      <button class="btn" onclick="doLogFetchOnce()">Fetch Once</button>
      <button class="btn" onclick="clearLogView()">Clear View</button>
    </div>
    <div id="log-container" class="card" style="margin-top: 8px; max-height: 360px;"></div>
  </div>

<script>
  const $ = (sel) => document.querySelector(sel);

  async function getJSON(url) {
    const r = await fetch(url);
    if (!r.ok) throw new Error(`HTTP ${r.status}`);
    return await r.json();
  }

  function clientLog(msg) {
    const el = document.createElement('p');
    el.className = 'logLine';
    el.textContent = `[client] ${msg}`;
    document.getElementById('log-container').appendChild(el);
  }

  function getSelectedModifier() {
    const el = document.querySelector('input[name="modifier"]:checked');
    return el ? el.value : '';
  }

  // Insert modifier (# or $) after the command token instead of appending at the end.
  function buildCommandWithModifier(raw, mod) {
    raw = String(raw || '').trim();
    if (!mod) return raw;
    // Remove trailing same modifier if user typed it at the end previously
    if (raw.endsWith(mod)) raw = raw.slice(0, -mod.length).trim();
    const parts = raw.split(/\s+/);
    if (!parts.length) return raw;
    // Ensure only one inline modifier at the end of the command token
    parts[0] = parts[0].replace(/[#$]+$/, '') + mod;
    return parts.join(' ');
  }

  async function populateServers() {
    try {
      const data = await getJSON('/servers');
      const sel = document.getElementById('server-select');
      sel.innerHTML = '';
      for (const s of (data.servers || [])) {
        const opt = document.createElement('option');
        opt.value = s.index;
        opt.textContent = `${s.name} (${s.host}:${s.port})`;
        sel.appendChild(opt);
      }
      /* removed servers pane */
    } catch (e) {
      /* removed servers pane */
    }
  }

  async function onSendClick() {
    const input = document.getElementById('command-input');
    const modifier = getSelectedModifier();
    const message = buildCommandWithModifier(input.value, modifier);

    const wait = document.getElementById('wait-response').checked;
    const quietMs = Number(document.getElementById('quiet-ms').value || 0);
    const maxMs   = Number(document.getElementById('max-ms').value || 0);

    const body = { command: message };
    if (wait) { body.quietMs = quietMs; body.maxMs = maxMs; }

    clientLog(`POST /send: ${JSON.stringify(body)}`);
    const r = await fetch('/send', { method:'POST', headers:{ 'content-type': 'application/json' }, body: JSON.stringify(body) });
    if (!r.ok) {
      const t = await r.text();
      clientLog(`HTTP ${r.status}: ${t}`);
      return;
    }
    const data = await r.json();
    clientLog(JSON.stringify(data));
  }

  async function doConnect(){
    const sel = document.getElementById('server-select');
    const idx = Number(sel.value || 0);
    const r = await fetch('/connect', { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify({ serverIndex: idx }) });
    clientLog(await r.text());
    await refreshStatus();
  }
  async function doDisconnect(){
    const r = await fetch('/disconnect', { method:'POST' });
    clientLog(await r.text());
    await refreshStatus();
  }

  async function refreshStatus() {
    try {
      const data = await getJSON('/status');
      document.getElementById('conn-status').textContent = data.connected ? `Connected to ${data.server ? (data.server.name || data.server.host) : 'server'}` : 'Not connected';
      // queue info (if exposed)
      try {
        const q = await getJSON('/commands/queue');
        document.getElementById('queue').textContent = JSON.stringify(q, null, 2);
      } catch (_) { /* optional */ }
    } catch (e) {
      document.getElementById('conn-status').textContent = String(e);
    }
  }

  async function doLogFetchOnce(){
    try {
      var limit = Number(document.getElementById('log-limit').value || 200);
      var r = await fetch('/logs?limit=' + limit + '&format=txt');
      var t = await r.text();
      var el = document.getElementById('log-container');
      el.innerHTML = '';
      var lines = t.split('
');
      for (var i = 0; i < lines.length; i++) {
        var raw = lines[i];
        if (!raw) continue;
        if (raw.charCodeAt(raw.length - 1) === 13) raw = raw.slice(0, -1); // trim CR
        var out = renderLogLine(raw);
        el.appendChild(out.node);
      }
      autoScrollIfNeeded();
    } catch (e) {
      clientLog('log fetch failed: ' + e.message);
    }
  }

  function renderLogLine(line){
    var node = document.createElement('div');
    node.className = 'logLine';

    var ts = '';
    var rest = line;
    if (line.length > 2 && line.charCodeAt(0) === 91) { // '['
      var rb = line.indexOf(']');
      if (rb > 0) {
        ts = line.slice(1, rb);
        rest = line.slice(rb + 1).trimStart();
      }
    }

    var tsSpan = document.createElement('span');
    tsSpan.className = 'ts';
    tsSpan.textContent = ts ? '[' + ts + '] ' : '';
    node.appendChild(tsSpan);

    var body = document.createElement('span');
    body.textContent = rest;

    var low = rest.toLowerCase();
    var cls = '';
    if (rest.indexOf('HTTP') === 0) cls = 'http';
    else if (rest.indexOf('CMD') === 0 || rest.indexOf('CMD/API') !== -1) cls = 'cmd';
    else if (rest.indexOf('RX <-') === 0 || rest.indexOf(' RX <-') !== -1) cls = 'rx';
    else if (low.indexOf('push') !== -1) cls = 'push';
    else if (low.indexOf('error') !== -1) cls = 'error';

    body.className = 'cat-' + (cls || 'plain');
    node.appendChild(body);
    return { node: node };
  }
      autoScrollIfNeeded();
    } catch (e) {
      clientLog('log fetch failed: ' + e.message);
    }
  }

  let tailTimer = null;
  function autoScrollIfNeeded(){
    if (!document.getElementById('auto-scroll').checked) return;
    const c = document.getElementById('log-container');
    c.scrollTop = c.scrollHeight + 1000;
  }
  function toggleTail(){
    const btn = document.getElementById('tail-toggle');
    if (tailTimer) { clearInterval(tailTimer); tailTimer = null; btn.textContent = 'Start Tail'; }
    else {
      tailTimer = setInterval(doLogFetchOnce, Math.max(250, Number(document.getElementById('log-interval').value || 2000)) );
      btn.textContent = 'Stop Tail';
    }
  }

  function clearLogView(){ document.getElementById('log-container').textContent = ''; }

  async function refreshRecv() {
    try {
      const limit = Number(document.getElementById('display-limit').value || 2048);
      const mode  = document.getElementById('display-encoding').value || 'text';
      const r = await getJSON(`/recv?limitBytes=${limit}&encoding=${mode}`);
      const el = document.getElementById('recv-container');
      el.textContent = `len=${r.length}, encoding=${r.encoding}\n` + r.data;
    } catch (e) {
      clientLog('recv fetch failed: ' + e.message);
    }
  }
  function clearRecv(){ const el = document.getElementById('recv-container'); el.textContent = ''; }

  async function populateCommands(){
    try {
      const data = await getJSON('/commands');
      const items = data.items || [];
      window.__items = items;
      renderCommandsTable();
    } catch (e) {
      const tb = document.getElementById('command-tbody');
      tb.innerHTML = `<tr><td colspan="3">${e.message}</td></tr>`;
    }
  }

  function renderCommandsTable(){
    const filt = (document.getElementById('cmd-filter').value || '').toLowerCase();
    const items = (window.__items || []).filter(it =>
      it.command.toLowerCase().includes(filt) ||
      it.description.toLowerCase().includes(filt) ||
      it.params.toLowerCase().includes(filt)
    );

    const tb = document.getElementById('command-tbody');
    tb.innerHTML = '';

    items.forEach(it => {
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td class="monospace" data-command="${it.command}">${it.command}</td>
        <td>${it.description}</td>
        <td class="monospace">${it.params}</td>`;
      tr.dataset.params = it.params || '';
      tr.addEventListener('click', () => {
        const mod = getSelectedModifier();
        const withMod = buildCommandWithModifier(it.command, mod);
        const full = it.params ? `${withMod} ${it.params}` : withMod;
        const input = document.getElementById('command-input');
        input.value = full;
        input.focus();
      });
      tb.appendChild(tr);
    });
  }

  async function init(){
    await populateServers();
    await refreshStatus();
    await populateCommands();
    toggleTail(); // start log tailing by default
  }

  window.addEventListener('load', init);
</script>

  

</body>
</html>

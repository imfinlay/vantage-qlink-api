<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>TCP Command Console</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 16px; }
    h1 { margin: 0 0 8px; }
    h2 { margin: 20px 0 8px; font-size: 1.1rem; }
    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .card { border: 1px solid #ddd; border-radius: 8px; padding: 12px; margin-top: 12px; }
    .btn { cursor: pointer; padding: 6px 10px; border: 1px solid #888; border-radius: 6px; background:#fafafa; }
    .btn:hover { background:#f0f0f0; }
    #output, #latest-response { white-space: pre-wrap; background:#f6f6f6; padding:10px; border:1px solid #ddd; border-radius: 6px; }
    #log-container, #recv-container { border: 1px solid #ccc; padding: 10px; max-height: 300px; overflow-y: auto; white-space: pre-wrap; background:#0b0b0b; color:#d7d7d7; border-radius: 6px; }
    table { width: 100%; border-collapse: collapse; }
    th, td { text-align: left; border-bottom: 1px solid #f0f0f0; padding: 6px; vertical-align: top; }
    th { border-bottom: 1px solid #ddd; }
    .muted { color:#666; font-size: 0.9em; }
    input[type="number"] { width: 7ch; }
    code { background:#f4f4f4; padding:2px 4px; border-radius:4px; }
  </style>
  <script>
    // ===== API helpers =====
    async function fetchServers() {
      const res = await fetch('/servers', { cache: 'no-store' });
      const data = await res.json();
      return Array.isArray(data) ? data : (Array.isArray(data.servers) ? data.servers : []);
    }
    async function fetchCommands() {
      const res = await fetch('/commands', { cache: 'no-store' });
      const data = await res.json();
      if (data && Array.isArray(data.items) && data.items.length) return data.items; // rich shape
      const cmds = (data && Array.isArray(data.commands)) ? data.commands : [];      // fallback
      return cmds.map(function(c){ return { command: c, params: '', description: '' }; });
    }
    async function fetchLogs(limit = 200) {
      const res = await fetch(`/logs?limit=${encodeURIComponent(limit)}`, { cache: 'no-store' });
      const data = await res.json();
      return Array.isArray(data) ? data : (Array.isArray(data.lines) ? data.lines : []);
    }
    async function fetchRecv(limitBytes = 2048, encoding = 'utf8') {
      const res = await fetch(`/recv?limitBytes=${encodeURIComponent(limitBytes)}&encoding=${encodeURIComponent(encoding)}`, { cache: 'no-store' });
      return res.json(); // { length, encoding, data }
    }
    async function connectToServer(serverIndex) {
      const res = await fetch('/connect', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ serverIndex }) });
      return res.json();
    }
    async function disconnect() {
      const res = await fetch('/disconnect', { method: 'POST' });
      return res.json();
    }
    async function sendCommand(message, waitMs) {
      const body = { command: message };
      if (typeof waitMs === 'number' && waitMs > 0) body.waitMs = waitMs;
      const res = await fetch('/send', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
      return res.json(); // { message, response? }
    }
    async function fetchStatus() {
      const res = await fetch('/status', { cache: 'no-store' });
      return res.json();
    }

    // ===== UI helpers =====
    function populateServers(servers) {
      const select = document.getElementById('server-select');
      select.innerHTML = '';
      servers.forEach(function(server, index){
        const option = document.createElement('option');
        option.value = index;
        option.textContent = server.name + ' (' + server.host + ':' + server.port + ')';
        select.appendChild(option);
      });
    }

    function getSelectedModifier() {
      const radios = document.querySelectorAll('input[name="modifier"]');
      for (var i=0; i<radios.length; i++) { if (radios[i].checked) return radios[i].value; }
      return '';
    }

    function setStatusText(connectedObj) {
      const el = document.getElementById('status');
      const connected = connectedObj && !!connectedObj.connected;
      var svr = (connectedObj && connectedObj.server) ? connectedObj.server : {};
      const label = svr.name || svr.host || '';
      el.textContent = connected ? ('Connected to ' + label) : 'Not connected';
    }

    async function onConnectClick() {
      const select = document.getElementById('server-select');
      const index = parseInt(select.value, 10);
      const result = await connectToServer(index);
      document.getElementById('output').textContent = result.message || JSON.stringify(result);
      const status = await fetchStatus(); setStatusText(status);
    }

    async function onDisconnectClick() {
      const result = await disconnect();
      document.getElementById('output').textContent = result.message || JSON.stringify(result);
      const status = await fetchStatus(); setStatusText(status);
    }

    async function onSendClick() {
      const input = document.getElementById('command-input');
      const modifier = getSelectedModifier();
      const message = input.value + (modifier || '');

      var waitMs = 0;
      const chk = document.getElementById('wait-enable');
      if (chk && chk.checked) {
        waitMs = parseInt(document.getElementById('wait-ms').value, 10) || 0;
      }

      const result = await sendCommand(message, waitMs);
      document.getElementById('output').textContent = result.message || JSON.stringify(result);

      // Show immediate response (if any)
      const respBox = document.getElementById('latest-response');
      if (result && result.response && typeof result.response.text === 'string') {
        respBox.textContent = result.response.text;
      } else {
        respBox.textContent = '(no response captured)';
      }
    }

    // ===== Commands: searchable table =====
    var __allCommands = [];

    function renderCommandsTable(rows) {
      const tbody = document.getElementById('commands-tbody');
      tbody.innerHTML = '';
      if (!rows.length) {
        const tr = document.createElement('tr');
        const td = document.createElement('td');
        td.colSpan = 3; td.className = 'muted'; td.style.padding = '8px';
        td.textContent = 'No commands loaded (check commands.csv)';
        tr.appendChild(td); tbody.appendChild(tr); return;
      }
      rows.forEach(function(row){
        const command = row.command, params = row.params, description = row.description;
        const tr = document.createElement('tr');
        [command, params, description].forEach(function(text){
          const td = document.createElement('td');
          td.textContent = text || ''; td.style.padding = '6px';
          tr.appendChild(td);
        });
        tr.style.cursor = 'pointer';
        tr.title = 'Click to insert the command into the input box';
        tr.addEventListener('click', function(){
          const input = document.getElementById('command-input');
          input.value = command; input.focus();
        });
        tbody.appendChild(tr);
      });
    }

    function applyCommandFilter() {
      const q = (document.getElementById('cmd-filter').value || '').toLowerCase();
      if (!q) return renderCommandsTable(__allCommands);
      const filtered = __allCommands.filter(function(row){
        const command = row.command || '', params = row.params || '', description = row.description || '';
        return command.toLowerCase().includes(q) || params.toLowerCase().includes(q) || description.toLowerCase().includes(q);
      });
      renderCommandsTable(filtered);
    }

    async function refreshCommandsUI() {
      try {
        __allCommands = await fetchCommands();
        renderCommandsTable(__allCommands);
      } catch (e) {
        console.error('Commands load failed:', e);
        __allCommands = []; renderCommandsTable(__allCommands);
      }
    }

    // ===== Logs live tail =====
    var logTimer = null;
    function stopLogTail() { if (logTimer) { clearInterval(logTimer); logTimer = null; } document.getElementById('tail-toggle').textContent = 'Start Tail'; }
    async function doLogFetchOnce() {
      const limit = parseInt(document.getElementById('log-limit').value, 10) || 200;
      const lines = await fetchLogs(limit);
      const box = document.getElementById('log-container');
      const auto = document.getElementById('auto-scroll').checked;
      box.textContent = lines.join('
');
      if (auto) box.scrollTop = box.scrollHeight;
      document.getElementById('log-count').textContent = '(' + lines.length + ' lines)';
    }
    function startLogTail() {
      const intervalMs = parseInt(document.getElementById('log-interval').value, 10) || 2000;
      if (logTimer) clearInterval(logTimer);
      logTimer = setInterval(doLogFetchOnce, intervalMs); doLogFetchOnce();
      document.getElementById('tail-toggle').textContent = 'Stop Tail';
    }
    function toggleTail() { if (logTimer) { stopLogTail(); } else { startLogTail(); } }
    function clearLogView() { document.getElementById('log-container').textContent = ''; document.getElementById('log-count').textContent = ''; }

    // ===== RECV live tail =====
    var recvTimer = null;
    function stopRecvTail() { if (recvTimer) { clearInterval(recvTimer); recvTimer = null; } document.getElementById('recv-toggle').textContent = 'Start Tail'; }
    async function doRecvFetchOnce() {
      const limit = parseInt(document.getElementById('recv-limit').value, 10) || 2048;
      const enc = document.getElementById('recv-enc').value || 'utf8';
      const res = await fetchRecv(limit, enc);
      const box = document.getElementById('recv-container');
      const auto = document.getElementById('recv-auto').checked;
      box.textContent = res && res.data ? res.data : '';
      if (auto) box.scrollTop = box.scrollHeight;
      document.getElementById('recv-count').textContent = '(' + (res.length || 0) + ' bytes)';
    }
    function startRecvTail() {
      const intervalMs = parseInt(document.getElementById('recv-interval').value, 10) || 2000;
      if (recvTimer) clearInterval(recvTimer);
      recvTimer = setInterval(doRecvFetchOnce, intervalMs); doRecvFetchOnce();
      document.getElementById('recv-toggle').textContent = 'Stop Tail';
    }
    function toggleRecv() { if (recvTimer) { stopRecvTail(); } else { startRecvTail(); } }
    function clearRecvView() { document.getElementById('recv-container').textContent = ''; document.getElementById('recv-count').textContent = ''; }

    // ===== Init =====
    async function initialize() {
      try {
        const servers = await fetchServers();
        populateServers(servers);
        const status = await fetchStatus(); setStatusText(status);
        await refreshCommandsUI(); startLogTail(); startRecvTail();
        const f = document.getElementById('cmd-filter'); if (f) f.addEventListener('input', applyCommandFilter);
      } catch (e) { console.error('Initialization error:', e); }
    }
    document.addEventListener('DOMContentLoaded', initialize);
  </script>
</head>
<body>
  <h1>TCP Command Console</h1>

  <div class="card">
    <h2>Server</h2>
    <div class="row">
      <label for="server-select">Select:</label>
      <select id="server-select"></select>
      <button class="btn" id="connect-btn" onclick="onConnectClick()">Connect</button>
      <button class="btn" id="disconnect-btn" onclick="onDisconnectClick()">Disconnect</button>
      <span id="status" class="muted">Not connected</span>
    </div>
  </div>

  <div class="card">
    <h2>Send Command</h2>
    <div class="row">
      <input id="command-input" type="text" placeholder="Enter command" />
      <div class="row" style="gap: 14px;">
        <label><input type="radio" name="modifier" value="" checked /> None</label>
        <label><input type="radio" name="modifier" value="$" /> $ (short)</label>
        <label><input type="radio" name="modifier" value="#" /> # (detailed)</label>
      </div>
      <div class="row" style="gap: 8px;">
        <label><input id="wait-enable" type="checkbox" /> Wait for response</label>
        <label>Wait (ms) <input id="wait-ms" type="number" min="0" step="50" value="300" /></label>
      </div>
      <button class="btn" id="send-btn" onclick="onSendClick()">Send</button>
    </div>
    <div style="margin-top: 8px;">
      <strong>Output:</strong>
      <pre id="output"></pre>
      <strong>Latest Response:</strong> <span class="muted">(from /send)</span>
      <pre id="latest-response"></pre>
    </div>
  </div>

  <div class="card">
    <h2>Commands</h2>
    <div class="row">
      <input id="cmd-filter" type="text" placeholder="Filter (command, params, description)" />
      <button class="btn" onclick="refreshCommandsUI()">Refresh</button>
      <span class="muted">Click a row to insert the command into the input.</span>
    </div>
    <div style="overflow:auto; margin-top:8px;">
      <table id="commands-table">
        <thead>
          <tr>
            <th>Command</th>
            <th>Params</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody id="commands-tbody"></tbody>
      </table>
    </div>
  </div>

  <div class="card">
    <h2>Logs <span id="log-count" class="muted"></span></h2>
    <div class="row">
      <label>Limit <input id="log-limit" type="number" min="10" max="2000" step="10" value="200" /></label>
      <label>Interval (ms) <input id="log-interval" type="number" min="250" step="250" value="2000" /></label>
      <label><input id="auto-scroll" type="checkbox" checked /> Auto-scroll</label>
      <button class="btn" id="tail-toggle" onclick="toggleTail()">Stop Tail</button>
      <button class="btn" onclick="doLogFetchOnce()">Fetch Once</button>
      <button class="btn" onclick="clearLogView()">Clear View</button>
    </div>
    <div id="log-container" class="card" style="margin-top: 8px; max-height: 360px;"></div>
  </div>

  <div class="card">
    <h2>Responses <span id="recv-count" class="muted"></span></h2>
    <div class="row">
      <label>Bytes <input id="recv-limit" type="number" min="64" max="32768" step="64" value="2048" /></label>
      <label>Interval (ms) <input id="recv-interval" type="number" min="250" step="250" value="2000" /></label>
      <label>Encoding 
        <select id="recv-enc">
          <option value="utf8" selected>utf8</option>
          <option value="hex">hex</option>
          <option value="base64">base64</option>
        </select>
      </label>
      <label><input id="recv-auto" type="checkbox" checked /> Auto-scroll</label>
      <button class="btn" id="recv-toggle" onclick="toggleRecv()">Stop Tail</button>
      <button class="btn" onclick="doRecvFetchOnce()">Fetch Once</button>
      <button class="btn" onclick="clearRecvView()">Clear View</button>
    </div>
    <div id="recv-container" class="card" style="margin-top: 8px; max-height: 360px;"></div>
  </div>
</body>
</html>
